在图论中，最短路径问题是找到图中两个顶点之间的最短路径，这里的“最短”通常指的是路径上的边权重之和最小。以下是三种常见的最短路径算法：
### 1. 迪杰斯特拉算法（Dijkstra's Algorithm）
[图-最短路径-Dijkstra(迪杰斯特拉)算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.999.0.0&vd_source=1970b1cb79523da04f01ebdee092447d)
迪杰斯特拉算法用于在有向图或无向图中找到一个顶点到图中其他所有顶点的最短路径。它适用于边权重非负的情况。

![[Pasted image 20240514012933.png]]

**工作原理：**
- 初始化：从源点开始，将源点到自身的距离设为0，到其他所有点的距离设为无穷大。
- 确定最短路径树（SPT）：每次从未确定最短路径的顶点中选择一个到源点距离最短的顶点，将其加入到SPT中。
- 更新邻接顶点的距离：对于每个刚加入SPT的顶点，检查其所有邻接顶点的距离，如果通过该顶点到达邻接顶点的路径比已知的路径短，则更新那些顶点的距离。

**伪代码：**
- 初始化
	- 设定所有点的distTo为无穷，设定所有点的edgeTo为0，设定初始点的distTo为0
	- 创建优先序列，优先序列包括图中的所有点
	- 创建已确定的最短路径序列，将原点加入
	- 循环：当优先序列不为空时候
		- 将当前路径最短的点A从优先序列弹出，并加入最短路径序列
		- 将点A执行relax，寻找下一个点B
- 宽松relax:
	- 获取达到A的最短路径
	- 获取A指向的其他点的长度
	- 计算A所有可一步达到的点所需的长度
	- 判断：是否已知距离大于通过A所能达到的最短距离
		- 如果最短距离w已在优先队列中，则仅更新优先队列中的下一个点
		- 如果不在，则将w更新入优先队列
![[Pasted image 20240514044551.png]]
![[Pasted image 20240514044607.png]]

### 2. 贝尔曼-福特算法（Bellman-Ford Algorithm）
[五分钟了解 Bellman-Ford_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18C4y137ck/?spm_id_from=333.788.recommend_more_video.-1&vd_source=1970b1cb79523da04f01ebdee092447d)
贝尔曼-福特算法可以处理图中包含负权边的情况。它能够计算单源最短路径，也可以检测负权回路。

**工作原理：**
- 初始化：设置源点到自身的距离为0，到其他所有点的距离为无穷大。
	- 松弛操作：对所有边重复进行松弛操作，即按照已经到达的点检查所有边，如果发现通过某条边到达其终点的距离可以被缩短，则更新该终点的距离。
- 检测负权回路：在理论上，经过顶点数减一次的松弛后，所有的最短路径都应该被找到。如果第n次仍然可以松弛边，那么图中存在负权回路。

### 3. 边加权有向无环图（Edge-Weighted DAG）
在边加权的有向无环图中，最短路径问题可以更高效地解决。由于图中无环，可以利用拓扑排序来计算最短路径。
![[Pasted image 20240514043441.png]]

**工作原理：**
- 拓扑排序：首先对图进行拓扑排序，确保每个顶点在其依赖顶点之后处理。
- 初始化：设置源点到自身的距离为0，到其他所有点的距离为无穷大。
- 松弛操作：按拓扑顺序处理每个顶点，并更新从该顶点出发可达的所有顶点的距离。

这三种算法各有适用场景和优势：
- 迪杰斯特拉算法适用于边权重非负的普通场景，
- 贝尔曼-福特算法可以处理更复杂的包含负权边的情况
- 有向无环图中，使用基于拓扑排序的方法则可以更加高效。
![[Pasted image 20240514020335.png]]
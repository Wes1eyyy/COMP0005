[图-最小生成树-Prim(普里姆)算法和Kruskal(克鲁斯卡尔)算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wG411z79G/?spm_id_from=333.999.0.0&vd_source=1970b1cb79523da04f01ebdee092447d)
Greedy算法(贪心算法):
仅根据当前最优的选择逐步选择的算法![[Pasted image 20240514011110.png]]
- 1.将图片切割为两部分，切割部分A和切割部分B
- 2.考虑A部分和B部分之间所有的边长
- 3.取最短的边长联通其指向的两点
- 4.再次进行切割，每次切割需要将已经联通的点切割进部分A
- 重复1-4,直到联通所有的点

Kruskal算法(加边法):
- 以找边为核心
- 先无视所有的边
- 将每个独立的点找到其中最短的边构成多个联通分量
- 直到将所有的点都串联在联通分量重
- 找到每个联通分量之间最短的边
![[Pasted image 20240514001642.png]]
**代码实现思路：**
- 将所有边长从短到长排序
- 从短到长依次联通图上的点
- 遇到已经联通的边就跳过
- 直到将所有点联通


Prim算法(加点法)：
- 以找点为核心
- 确定一个出发点，找到与已联通部分最短的边，点亮(联通)下个点
- 直到联通所有的点
![[Pasted image 20240514000801.png]]
- 边的数量不影响效率：更适合稠密图(Dense graph)
- 存在A点有着多个相同长边时，Prim算法也会有多个结果
**编程实现思路：**
- 将所有边长由短到长排序
- 从起始点出发，考虑所有为联通点和已经联通部分的边长
- 取最短的边长联通其点
- 直到将所有点联通




一种构建有序序列的排序算法，适用于少量数据的排序，算法简单直观。

![[Pasted image 20240513033600.png]]

方法思路：
- 1. 从第一个元素开始，该元素可以认为已经被排序。
- 2. 取出下一个元素，在已排序的元素序列中从后向前扫描。
- 3. 如果已排序的元素大于新元素，将该已排序元素移到下一位置。
- 4. 重复步骤3，直到找到已排序的元素小于或等于新元素的位置。
- 5. 将新元素插入到该位置中。
- 6. 重复步骤2-5，直到所有元素均已排序。

时间复杂度：O($N^2$)

**优点**：
  - **简单且直观**：易于实现，代码简洁。
  - **适用于小数据集**：在数据量较小或几乎已经排序的数据集上效率很高。
  - **稳定排序**：相等元素的相对顺序不会改变。
  - **在线排序**：可以在接收数据时进行排序。
  - **原地排序**：不需要额外的存储空间。

**缺点**：
  - **效率低下**：在数据规模较大或完全无序的情况下表现不佳，时间复杂度为O(N^2)。
  - **不适合大数据集**：比较次数和移动次数都较多。

**代码实现**
```java
public static void  insert_sort(int array[],int lenth){

   int temp;

   for(int i=0;i<lenth-1;i++){
       for(int j=i+1;j>0;j--){
           if(array[j] < array[j-1]){
               temp = array[j-1];
               array[j-1] = array[j];
               array[j] = temp;
           }else{         //不需要交换
               break;
           }
       }
   }
}
```
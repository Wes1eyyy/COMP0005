[【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.788.recommend_more_video.4&vd_source=1970b1cb79523da04f01ebdee092447d)
一种利用堆这种数据结构设计的排序算法。

![堆排序示意图](排序(Sort)/图片/Pasted image 20240513033742.png)

方法思路：
- 1. 将待排序数组构造成一个最大堆或最小堆。
- 2. 将堆顶元素（最大值或最小值）与堆的最后一个元素交换，并将交换后的最后一个元素从堆中移除。
- 3. 对剩余的堆进行调整，使其重新成为最大堆或最小堆。
- 4. 重复步骤2和3，直到堆中只剩下一个元素。

代码实现思路:
- 1. 构建初始堆：
  - a. 从最后一个非叶子节点开始，向上调整每个节点，使整个数组满足堆的性质。
- 2. 堆排序过程：
  - a. 将堆顶元素与堆的最后一个元素交换。
  - b. 将堆的大小减1，将最后一个元素移出堆。
  - c. 对堆顶元素进行向下调整，使剩余元素重新满足堆的性质。
  - d. 重复步骤a-c，直到堆的大小为1。

时间复杂度：O($Nlog_N$)

堆排序的时间复杂度分析：
- 构建初始堆的过程需要O(N)次操作。
- 每次从堆中取出最大元素，并对剩余元素进行调整，这个过程需要O(log N)次操作，重复N次。
- 因此，总的时间复杂度是O(N log N)。

**优点**：
  - **高效且稳定**：堆排序的时间复杂度为O(N log N)，这使得它在处理大数据集时非常有效。
  - **不依赖于数据分布**：由于它是基于比较的排序，其性能不会因数据的初始顺序而变差，如快速排序可能在最坏情况下退化。
  - **原地排序**：虽然它是一种原地排序算法，但它的空间复杂度仍然很低，因为除了堆本身外不需要额外的存储空间。

**缺点**：
  - **不稳定排序**：在进行元素的交换过程中，相等的元素可能会改变其原始顺序，导致排序结果不稳定。
  - **相对复杂的实现**：与简单排序算法（如插入排序、选择排序）相比，堆排序的实现较为复杂。
  - **对缓存不友好**：堆排序访问数据的模式可能导致较差的缓存性能，因为元素之间的访问距离较远，不像其他一些算法那样局部性好。

![[Pasted image 20240513033752.png]]

**代码实现**
```java
//构建最小堆
public static void MakeMinHeap(int a[], int n){
 for(int i=(n-1)/2 ; i>=0 ; i--){
     MinHeapFixdown(a,i,n);
 }
}
//从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  
public static void MinHeapFixdown(int a[],int i,int n){

   int j = 2*i+1; //子节点
   int temp = 0;

   while(j<n){
       //在左右子节点中寻找最小的
       if(j+1<n && a[j+1]<a[j]){   
           j++;
       }

       if(a[i] <= a[j])
           break;

       //较大节点下移
       temp = a[i];
       a[i] = a[j];
       a[j] = temp;

       i = j;
       j = 2*i+1;
   }
}
```

```java
public static void MinHeap_Sort(int a[],int n){
  int temp = 0;
  MakeMinHeap(a,n);

  for(int i=n-1;i>0;i--){
      temp = a[0];
      a[0] = a[i];
      a[i] = temp; 
      MinHeapFixdown(a,0,i);
  }     
}
```

一种使用双指针的排序算法。

方法思路：
- 1．先从数列中取出一个数作为基准数。
- 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
- 3．再对左右区间重复第二步，直到各区间只有一个数。

代码实现思路:
- 1．i = L; j = R; 将基准数挖出形成第一个坑a[i]。
- 2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
- 3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
- 4．再重复执行2，3二步，直到i == j，将基准数填入a[i]中。

时间复杂度：O($Nlog_N$)

**优点**：
  - **高效**：平均情况下的时间复杂度为O(N log N)。
  - **原地排序**：除了递归栈，不需要额外的存储空间。
  - **广泛使用**：因其效率和简单性，被广泛使用于多种标准库的排序功能。

**缺点**：
  - **最坏情况性能差**：在最坏的情况下，如数组已排序或接近排序完毕时，性能会降至O(N^2)。
  - **不稳定排序**：可能会改变等值元素的相对顺序。
  - **递归深度问题**：快速排序依赖于递归，极端情况下可能导致递归调用栈溢出。

**代码实现**
```java
public static void quickSort(int a[],int l,int r){
     if(l>=r)
       return;

     int i = l; int j = r; int key = a[l];//选择第一个数为key

     while(i<j){

         while(i<j && a[j]>=key)//从右向左找第一个小于key的值
             j--;
         if(i<j){
             a[i] = a[j];
             i++;
         }

         while(i<j && a[i]<key)//从左向右找第一个大于key的值
             i++;

         if(i<j){
             a[j] = a[i];
             j--;
         }
     }
     //i == j
     a[i] = key;
     quickSort(a, l, i-1);//递归调用
     quickSort(a, i+1, r);//递归调用
 }
```
### 1. 暴力法（Brute Force）

**原理**：
暴力法是最简单直接的子字符串搜索方法。它通过检查主字符串中的所有可能的起始位置，然后对每个位置，逐个字符地匹配子字符串。

**步骤**：
- 对主字符串的每一个位置，从左到右开始匹配子字符串。
- 如果在某个位置，子字符串的每个字符依次与主字符串中的字符匹配，则返回该位置作为匹配的开始位置。
- 如果在某个位置匹配失败（即发现不匹配的字符），则主字符串的索引后移一位，重新开始匹配。

**效率**：
- 时间复杂度：最坏情况下为 $O(mn)$，其中 $m$ 是主字符串的长度，$n$ 是子字符串的长度。
- 空间复杂度：$O(1)$。

![[Pasted image 20240514071655.png]]

### 2. Knuth-Morris-Pratt算法（KMP）
![[Pasted image 20240514072814.png]]
**原理**：
KMP算法通过预处理子字符串来创建一个部分匹配表（也称为"前缀表"），用于在发生不匹配时，将子字符串向右滑动多于一位的距离，而无需重新检查之前已经匹配的字符。

**步骤**：
- **预处理**：计算部分匹配表，表中的每个值表示在不匹配发生时子字符串中可以安全跳过的字符数。
- **搜索**：使用部分匹配表，对主字符串进行扫描，有效地跳过那些根据部分匹配表不可能匹配的位置。

**效率**：
- 时间复杂度：$O(m + n)$。
- 空间复杂度：$O(n)$，用于存储部分匹配表。
![[Pasted image 20240514072849.png]]
![[Pasted image 20240514073646.png]]
### 3. Boyer-Moore算法

**原理**：
Boyer-Moore算法是一种高效的子字符串搜索算法，它从子字符串的末尾开始比较。Boyer-Moore利用两种启发式方法（坏字符规则和好后缀规则）来实现在不匹配发生时尽可能地跳过更多的字符。

**步骤**：
- **坏字符规则**：当字符不匹配时，查看这个坏字符是否在子字符串中出现过，如果未出现，可以安全地跳过整个子字符串的长度；如果出现过，移动子字符串，使子字符串中的最右侧的相同字符对齐这个坏字符的位置。
- **好后缀规则**：当一段后缀是好的（即匹配的）时，尝试找到在子字符串中这个好后缀出现的另一个位置，并对齐这两处。

**效率**：
- 时间复杂度：平均情况下为 $O(n/m)$，最坏情况为 $O(mn)$。
- 空间复杂度：取决于用于存储坏字符和好后缀数据结构的空间。
![[Pasted image 20240514081640.png]]


### 总结

这三种算法各有优势和劣势。
- 暴力法虽然实现简单，但效率较低；
- KMP算法通过预处理提高了匹配的效率，适用于重复搜索同一子字符串的场景；
- Boyer-Moore算法则在大多数实际情况下提供了最快的搜索速度，尤其是当子字符串较长时。选择哪种算法取决于具体的应用需求、预期的文本和子字符串长度以及对性能的要求。